# Bazy danych 2 Projekt
# Stas Kochevenko, Wiktor Dybalski

## 1. **Opis projektu**

W ramach projektu została stworzona strona kina z możliwością rejestracji, logowania się na stronie, rezerwacją i zakupem biletów na dostępne seanse. Wybrane przez nas technologie: PostgreSQL (baza danych), ReactJS (frontend), Django (backend).

## 2. **Schemat bazy danych**

![dbschema](img/schema.png)

Dany schemat przedstawia podstawowe encje, niezbędne do poprawnego działania strony kina. Do uproszczenia modelu bazy danych przyjęliśmy kilka zasad:

1. Kino posiada tylko jedną lokalizację
2. Wszystkie filmy są przydzielone tylko jednej kategorii oraz posiadają tylko jednego reżysera
3. Seanse filmów odbywają się w salach (1-6), przy czym każda sala posiada taką samą liczbę miejsc (84), chociaż to zawsze można zmienić
4. Bilety na seans mają dwie ceny: Standard & Premium. Premium-bilet odpowiada ostatniemu rzędowi w kinie, czyli miejscom 1-11
5. Klienci mogą kupować i rezerwować bilety na określone miejsca. W przypadku rezerwacji w profilu mają oni możliwość kupienia danego biletu albo jego anulowania
6. Każdy bilet posiada status. Istnieją 3 opcję tego statusu: "New" - nowy nieopłacony bilet (rezerwacja), "Confirmed" - opłacony bilet (nie da się jego anulować), "Canceled" - anulowany bilet
7. Klienci nie mogą zarezewować miejsca na seans, do rozpoczęcia którego pozostało mniej niż 2 godziny. W takim przypadku mogą oni wyłącznie kupić bilet na dane miejsce
8. Na stronie ustawiliśmy datę 22-05-2024 oraz czas 13-00, który jest "aktualnym" czasem przeglądania strony. To jest umotywowane tym, że filmy i seansy są ustawione na określone daty, więc stała data była wygodna do testowania poprawności działania systemu i bazy danych
9. Nie udało się zrealizować utworzenia sesji użytkownika na froncie (mimo, że logowanie i rejestracja na poziomie backendu i bazy danych działają poprawnie), więc na stronie ustawiliśmy użytkownika domyślnego i ID = 6

Najważniejsze pliki naszego serwera Django:

    - views -> Zawiera logikę widoków, czyli funkcje lub klasy, które przetwarzają żądania HTTP i zwracają odpowiedzi.
    - urls -> Definiuje routing URL-ów dla projektu. Mapa URL do odpowiednich widoków (łączy widok (view) z odpowiednim urlem).
    - models -> Definiuje modele danych, które mapują na tabele w bazie danych. Każdy model reprezentuje klasę Pythona.

Przepływ danych pomiędzy Reactem, Django oraz Bazą danych w naszym projekcie przedstawiony na przykładzie pobranie kategorii filmów z bazy danych:

Przykładowy request od Reacta:
```react
       useEffect(() => {
        fetch('http://127.0.0.1:8000/api/categories')
            .then(response => response.json())
            .then(data => setCategories(data))
            .catch(error => console.error('Error fetching movie categories: ', error));
    }, []);
```

Odpowiednia obsługa endpointu serwera za pomocą funkcji get_categories w views:

```python
path('categories/', views.get_categories, name='categories'),
```

Funkcja get_categories:

```python
def get_categories(request):
    try:
        with connection.cursor() as cursor:
            cursor.execute("SELECT * FROM movie_categories")
            columns = [col[0] for col in cursor.description]
            categories = []
            for row in cursor.fetchall():
                category = dict(zip(columns, row))
                categories.append(category)
        return JsonResponse(categories, safe=False)
    except Exception as e:
        return JsonResponse({'error': str(e)}, status=500)
```

## 3. **Tabele**

- user_api_app_user

Tabela została wygenerowana przez django, połączyliśmy ją z tabelą Tickets

```postgresql
create table user_api_appuser
(
    password     varchar(128) not null,
    last_login   timestamp with time zone,
    is_superuser boolean      not null,
    user_id      integer generated by default as identity
        primary key,
    email        varchar(50)  not null
        unique,
    username     varchar(50)  not null,
    is_active    boolean      not null,
    is_staff     boolean      not null
);

alter table user_api_appuser
    owner to postgres;

create index user_api_appuser_email_8e98cebd_like
    on user_api_appuser (email varchar_pattern_ops);
```

![user_api_app_user](img/1.png)

- movie_categories

```postgresql
create table movie_categories
(
    moviecategoryid integer default nextval('moviecategories_moviecategoryid_seq'::regclass) not null
        constraint moviecategories_pk
            primary key,
    categoryname    varchar(40)                                                              not null
);

alter table movie_categories
    owner to postgres;
```

![movie_categories](img/2.png)

- movies

```postgresql
create table movies
(
    movieid          serial
        constraint movies_pk
            primary key,
    moviecategoryid  integer          not null
        constraint product_category_product
            references movie_categories,
    title            varchar(40)      not null,
    startdate        date             not null,
    enddate          date             not null,
    duration         integer          not null,
    description      varchar(255)     not null,
    image            bytea            not null,
    director         varchar(40)      not null,
    minage           integer          not null,
    production       varchar(40)      not null,
    originallanguage varchar(40)      not null,
    rank             double precision not null
);

alter table movies
    owner to postgres;
```

![movies](img/3.png)

- movie_halls

Może się wydawać, że wystarczyło by samo ID, ale biezpieczniej mieć osobną kolumnę, bo w przypadku usunięcia kolejny ID będzie coraz większy

```postgresql
create table movie_halls
(
    moviehallid serial
        primary key,
    hall_number integer not null
        constraint movie_halls_hall_number_unique
            unique
);

alter table movie_halls
    owner to postgres;
```

![movie_halls](img/4.png)

- movie_screening

Tabela przedstawia konkretny seans filmu

```postgresql
create table movie_screening
(
    moviescreeningid serial
        constraint movie_screening_pk
            primary key,
    movieid          integer        not null
        constraint session_movies
            references movies,
    date             date           not null,
    starttime        time           not null,
    endtime          time           not null,
    pricestandard    numeric(12, 2) not null,
    pricepremium     numeric(12, 2) not null,
    threedimensional boolean        not null,
    language         varchar(40)    not null,
    hallnumber       integer        not null
        constraint hallnumber
            references movie_halls (hall_number)
);

alter table movie_screening
    owner to postgres;
```

![movie_screening](img/5.png)

- hall_seats

```postgresql
create table hall_seats
(
    seatid          serial
        constraint hall_seats_pk
            primary key,
    seatnumber      integer not null,
    moviehallnumber integer not null
        constraint hallseats_moviehalls
            references movie_halls (hall_number)
);

alter table hall_seats
    owner to postgres;
```

![hall_seats](img/6.png)

- tickets

```postgresql
create table tickets
(
    ticketid         integer default nextval('tickets_tickedid_seq'::regclass) not null
        constraint tickets_pk
            primary key,
    customerid       integer                                                   not null
        constraint client_purchase
            references user_api_appuser,
    orderedondate    date                                                      not null,
    orderedontime    time                                                      not null,
    status           char(10)                                                  not null,
    moviescreeningid integer                                                   not null
        constraint tickets_moviescreening
            references movie_screening,
    seatnumber       integer                                                   not null
        constraint tickets_hallseats
            references hall_seats
);

alter table tickets
    owner to postgres;
```

![tickets](img/7.png)

- triger validate_reservation_time

```postgresql
create trigger validate_reservation_time
    before insert
    on tickets
    for each row
execute procedure check_reservation_period();
```

## 4. **Widoki**

- Wyświetlenie danych o wszystkich zajętych miejscach na określony seans

```postgresql
reate view occupied_seats(id, seatnumber, hallnumber, moviescreeningid) as
SELECT row_number() OVER (ORDER BY tickets.moviescreeningid, tickets.seatnumber) AS id,
       tickets.seatnumber,
       movie_screening.hallnumber,
       tickets.moviescreeningid
FROM tickets
         JOIN movie_screening ON tickets.moviescreeningid = movie_screening.moviescreeningid;

alter table occupied_seats
    owner to postgres;
```

![](img/8.png)

- Średnia cena biletu (standardowa i premium) dla danej kategorii wraz z liczbą seansów w okresie +- 6 miesięcy

```postgresql
create view average_ticket_prices_by_category
            (categoryname, moviescreenings_amount, average_pricestandard, average_pricepremium) as
SELECT mc.categoryname,
       count(ms.moviescreeningid)                                                         AS moviescreenings_amount,
       round(COALESCE(sum(ms.pricestandard) / count(ms.movieid)::numeric, 0::numeric), 2) AS average_pricestandard,
       round(COALESCE(sum(ms.pricepremium) / count(ms.movieid)::numeric, 0::numeric), 2)  AS average_pricepremium
FROM movie_categories mc
         LEFT JOIN movies m ON mc.moviecategoryid = m.moviecategoryid
         LEFT JOIN movie_screening ms ON m.movieid = ms.movieid AND ms.date >= (CURRENT_DATE - '6 mons'::interval)
GROUP BY mc.categoryname;

alter table average_ticket_prices_by_category
    owner to postgres;
```

![](img/9.png)

- Zysk dla każdego filmu wraz z datą zakupu biletów

```postgresql
create view movies_revenue (title, categoryname, startdate, enddate, orderedondate, tickets_amount, revenue) as
SELECT m.title,
       mc.categoryname,
       m.startdate,
       m.enddate,
       t.orderedondate,
       COALESCE(count(t.ticketid), 0::bigint) AS tickets_amount,
       COALESCE(sum(
                        CASE
                            WHEN t.ticketid IS NOT NULL AND is_premium_place(t.seatnumber) THEN ms.pricepremium
                            WHEN t.ticketid IS NOT NULL THEN ms.pricestandard
                            ELSE 0::numeric
                            END), 0::numeric) AS revenue
FROM movies m
         JOIN movie_categories mc ON m.moviecategoryid = mc.moviecategoryid
         LEFT JOIN movie_screening ms ON m.movieid = ms.movieid
         LEFT JOIN tickets t ON ms.moviescreeningid = t.moviescreeningid
GROUP BY m.title, mc.categoryname, m.startdate, m.enddate, t.orderedondate;

alter table movies_revenue
    owner to postgres;
```

![](img/10.png)

## 5. **Procedury**

### Testowanie poprawności działania procedur będzie pokazane w sekcji niżej, na przykładach z frontendu strony

- Rezerwacja miejsca na określony seans

```postgresql
create procedure reserve_movie_screening_seat(IN p_customer_id integer, IN p_seat_number integer, IN p_movie_screening_id integer, IN p_curr_date date, IN p_curr_time time without time zone)
    language plpgsql
as
$$
BEGIN
    IF exists(select *
              from occupied_seats as oc
              where oc.MovieScreeningID = p_movie_screening_id and oc.seatnumber = p_seat_number) THEN
        RAISE EXCEPTION 'The place has been already occupied';
    END IF;
    INSERT INTO tickets (customerid, moviescreeningid, seatnumber, orderedondate, orderedontime, status)
    VALUES (p_customer_id, p_movie_screening_id, p_seat_number, p_curr_date, p_curr_time, 'New');
END;
$$;

alter procedure reserve_movie_screening_seat(integer, integer, integer, date, time) owner to postgres;
```

- Zakup miejsca na określony seans

```postgresql
create procedure buy_movie_screening_seat(IN p_customer_id integer, IN p_seat_number integer, IN p_movie_screening_id integer, IN p_curr_date date, IN p_curr_time time without time zone)
    language plpgsql
as
$$
BEGIN
    IF exists(select *
              from occupied_seats as oc
              where oc.MovieScreeningID = p_movie_screening_id and oc.seatnumber = p_seat_number) THEN
        RAISE EXCEPTION 'The place has been already occupied';
    END IF;
    INSERT INTO tickets (customerid, moviescreeningid, seatnumber, orderedondate, orderedontime, status)
    VALUES (p_customer_id, p_movie_screening_id, p_seat_number, p_curr_date, p_curr_time, 'Confirmed');
END;
$$;

alter procedure buy_movie_screening_seat(integer, integer, integer, date, time) owner to postgres;

create procedure update_ticket_status(IN p_ticket_id integer, IN p_new_status character)
    language plpgsql
as
$$
BEGIN
    -- Checking the current status of the ticket
    DECLARE
        v_current_status CHAR(10);
    BEGIN
        SELECT status INTO v_current_status
        FROM tickets
        WHERE ticketid = p_ticket_id;

        -- If the current status of the ticket is "Confirmed", do not change it
        IF v_current_status = 'Confirmed' THEN
            RAISE NOTICE 'The ticket status is confirmed and cannot be changed.';
            RETURN;
        END IF;

        -- If the current status of the ticket is "New", allow changing it to "Canceled" or "Confirmed"
        IF v_current_status = 'New' THEN
            IF p_new_status = 'Canceled' OR p_new_status = 'Confirmed' THEN
                UPDATE tickets
                SET status = p_new_status
                WHERE ticketid = p_ticket_id;
                RAISE NOTICE 'Ticket status successfully updated to %.', p_new_status;
            ELSE
                RAISE NOTICE 'The ticket status can only be changed to "Canceled" or "Confirmed".';
            END IF;
        END IF;
    END;
END;
$$;

alter procedure update_ticket_status(integer, char) owner to postgres;
```

- Dodanie nowej kategorii (admin)

```postgresql
create procedure add_movie_category(IN p_categoryname character varying)
    language plpgsql
as
$$
BEGIN
    -- Insert new category into movie_categories table
    INSERT INTO movie_categories (categoryname)
    VALUES (p_categoryname);
END;
$$;

alter procedure add_movie_category(varchar) owner to postgres;

create procedure delete_movie_category(IN p_moviecategoryid integer)
    language plpgsql
as
$$
BEGIN
    -- Check if the category exists
    IF NOT EXISTS (SELECT 1 FROM movie_categories WHERE moviecategoryid = p_moviecategoryid) THEN
        RAISE EXCEPTION 'Category with id % does not exist', p_moviecategoryid;
    END IF;

    -- Check if any movie exists with this category
    IF EXISTS (SELECT 1 FROM movies WHERE moviecategoryid = p_moviecategoryid) THEN
        RAISE EXCEPTION 'Cannot delete category because there are movies associated with it';
    END IF;

    -- Delete the category
    DELETE FROM movie_categories
    WHERE moviecategoryid = p_moviecategoryid;
END;
$$;

alter procedure delete_movie_category(integer) owner to postgres;
```

- Usunięcie wybranej kategorii (admin)

```postgresql
create procedure delete_movie_category(IN p_categoryname character varying)
    language plpgsql
as
$$
DECLARE
    v_moviecategoryid integer;
BEGIN
    SELECT moviecategoryid INTO v_moviecategoryid
    FROM movie_categories
    WHERE categoryname = p_categoryname;

    IF v_moviecategoryid IS NULL THEN
        RAISE EXCEPTION 'Category with name % does not exist', p_categoryname;
    END IF;

    IF EXISTS (SELECT 1 FROM movies WHERE moviecategoryid = v_moviecategoryid) THEN
        RAISE EXCEPTION 'Cannot delete category because there are movies associated with it';
    END IF;

    DELETE FROM movie_categories
    WHERE moviecategoryid = v_moviecategoryid;
END;
$$;

alter procedure delete_movie_category(varchar) owner to postgres;
```

- Usunięcie wybranego filmu (admin)

```postgresql
create procedure delete_movie_by_name(IN p_movie_title text)
    language plpgsql
as
$$
BEGIN
    -- Check if movie with the given name exists
    IF NOT EXISTS (SELECT 1 FROM movies WHERE title = p_movie_title) THEN
        RAISE EXCEPTION 'Movie with name % does not exist', p_movie_title;
    END IF;

    -- Delete the movie
    DELETE FROM movies
    WHERE title = p_movie_title;
END;
$$;

alter procedure delete_movie_by_name(text) owner to postgres;
```

- Dodanie nowego filmu (admin)

```postgresql
create procedure add_movie(IN p_moviecategoryname character varying, IN p_title character varying, IN p_startdate date, IN p_enddate date, IN p_duration integer, IN p_description character varying, IN p_image bytea, IN p_director character varying, IN p_minage integer, IN p_production character varying, IN p_originallanguage character varying, IN p_rank double precision)
    language plpgsql
as
$$
DECLARE
    v_category_id INTEGER;
BEGIN
    -- Get movie category id from category name
    SELECT moviecategoryid INTO v_category_id FROM movie_categories WHERE categoryname = p_moviecategoryname;

    -- Check if category id is NULL, which means no matching category found
    IF v_category_id IS NULL THEN
        RAISE EXCEPTION 'Movie category % does not exist', p_moviecategoryname;
    END IF;

    -- Check if enddate is greater than startdate
    IF p_enddate <= p_startdate THEN
        RAISE EXCEPTION 'End date must be greater than start date';
    END IF;

    -- Check if duration is at least 30 minutes
    IF p_duration < 30 THEN
        RAISE EXCEPTION 'Duration must be at least 30 minutes';
    END IF;

    -- Check if rank is between 0 and 10
    IF p_rank < 0 OR p_rank > 10 THEN
        RAISE EXCEPTION 'Rank must be between 0 and 10';
    END IF;

    -- Check if minage is between 0 and 21
    IF p_minage < 0 OR p_minage > 21 THEN
        RAISE EXCEPTION 'Minimum age must be between 0 and 21';
    END IF;

    -- Insert the new movie into the movies table
    INSERT INTO movies (
        moviecategoryid, title, startdate, enddate, duration, description,
        image, director, minage, production, originallanguage, rank
    ) VALUES (
        v_category_id, p_title, p_startdate, p_enddate, p_duration, p_description,
        p_image, p_director, p_minage, p_production, p_originallanguage, p_rank
    );
END;
$$;

alter procedure add_movie_by_name(varchar, varchar, date, date, integer, varchar, bytea, varchar, integer, varchar, varchar, double precision) owner to postgres;
```

- Aktualizacja danych danego filmu (admin)

```postgresql
create procedure update_movie_by_name(IN p_moviecategoryname character varying, IN p_title character varying, IN p_startdate date, IN p_enddate date, IN p_duration integer, IN p_description character varying, IN p_image bytea, IN p_director character varying, IN p_minage integer, IN p_production character varying, IN p_originallanguage character varying, IN p_rank double precision)
    language plpgsql
as
$$
DECLARE
    v_movie_id INTEGER;
    v_category_id INTEGER;
BEGIN
    -- Get movie ID from title
    SELECT movieid INTO v_movie_id FROM movies WHERE title = p_title;

    -- Check if movie with the given title exists
    IF v_movie_id IS NULL THEN
        RAISE EXCEPTION 'Movie with title % does not exist', p_title;
    END IF;

    -- Get movie category id from category name
    SELECT moviecategoryid INTO v_category_id FROM movie_categories WHERE categoryname = p_moviecategoryname;

    -- Check if category name exists
    IF v_category_id IS NULL THEN
        RAISE EXCEPTION 'Movie category % does not exist', p_moviecategoryname;
    END IF;

    -- Check if end date is greater than start date
    IF p_enddate <= p_startdate THEN
        RAISE EXCEPTION 'End date must be greater than start date';
    END IF;

    -- Check if duration is at least 30 minutes
    IF p_duration < 30 THEN
        RAISE EXCEPTION 'Duration must be at least 30 minutes';
    END IF;

    -- Check if rank is between 0 and 10
    IF p_rank < 0 OR p_rank > 10 THEN
        RAISE EXCEPTION 'Rank must be between 0 and 10';
    END IF;

    -- Check if minage is between 0 and 21
    IF p_minage < 0 OR p_minage > 21 THEN
        RAISE EXCEPTION 'Minimum age must be between 0 and 21';
    END IF;

    -- Update the movie information
    UPDATE movies
    SET
        moviecategoryid = v_category_id,
        title = p_title,
        startdate = p_startdate,
        enddate = p_enddate,
        duration = p_duration,
        description = p_description,
        image = p_image,
        director = p_director,
        minage = p_minage,
        production = p_production,
        originallanguage = p_originallanguage,
        rank = p_rank
    WHERE
        movieid = v_movie_id;
END;
$$;

alter procedure update_movie_by_name(varchar, varchar, date, date, integer, varchar, bytea, varchar, integer, varchar, varchar, double precision) owner to postgres;
```

- Dodanie seansów z określonym zestawem danych na określoną liczbę dni (admin)
Są dodawane dokładnie takie same dane dla podanej liczby dni

```postgresql
create procedure add_movie_screenings_weekly(IN movie_title character varying, IN start_date date, IN start_time time without time zone, IN price_standard numeric, IN price_premium numeric, IN is_3d boolean, IN language_val character varying, IN hall_number integer, IN repeat_count integer)
    language plpgsql
as
$$
DECLARE
    movie_id integer;
    current_date_val date := start_date;
    iteration integer := 1;
BEGIN
    -- Retrieve the movie_id based on the title
    SELECT movieid INTO movie_id
    FROM movies
    WHERE title = movie_title;

    -- Check if the movie exists
    IF movie_id IS NULL THEN
        RAISE EXCEPTION 'Movie with title % does not exist', movie_title;
    END IF;

    -- Check if the repeat_count is within the valid range
    IF repeat_count < 1 OR repeat_count > 14 THEN
        RAISE EXCEPTION 'Repeat count % is out of the valid range (1-14)', repeat_count;
    END IF;

    -- Loop to add movie screenings for the specified number of repeat days
    WHILE iteration <= repeat_count LOOP
        CALL add_movie_screening(
            movie_title,
            current_date_val,
            start_time,
            price_standard,
            price_premium,
            is_3d,
            language_val,
            hall_number
        );

        -- Move to the next day
        current_date_val := current_date_val + 1;
        iteration := iteration + 1;
    END LOOP;
END;
$$;

alter procedure add_movie_screenings_weekly(varchar, date, time, numeric, numeric, boolean, varchar, integer, integer) owner to postgres;
```

- Dodanie nowego seansu dla danego filmu (admin)

```postgresql
create procedure add_movie_screening(IN title_val character varying, IN date_val date, IN start_time_val time without time zone, IN price_standard_val numeric, IN price_premium_val numeric, IN is_3d boolean, IN language_val character varying, IN hall_val integer)
    language plpgsql
as
$$
DECLARE
    movie_id integer;
    duration_val int;
    end_time_val time;
    hall_available boolean;
BEGIN
    -- Retrieve the movie_id and duration based on the title
    SELECT m.movieid, m.duration INTO movie_id, duration_val
    FROM movies m
    WHERE m.title = title_val
    AND date_val BETWEEN m.startdate AND m.enddate; -- Check if date_val is between startdate and enddate of the movie

    -- Check if the movie exists
    IF movie_id IS NULL THEN
        RAISE EXCEPTION 'Movie with title % does not exist or is not available on the specified date', title_val;
    END IF;

    -- Check if the movie hall exists
    IF NOT EXISTS (SELECT 1 FROM movie_halls WHERE hall_number = hall_val) THEN
        RAISE EXCEPTION 'Movie hall with id % does not exist', hall_val;
    END IF;

    -- Calculate the end time of the screening
    SELECT calculate_end_time(start_time_val, duration_val) INTO end_time_val;

    -- Check if the movie hall is available
    hall_available := is_moviehall_available(hall_val, date_val, start_time_val, end_time_val);
    IF NOT hall_available THEN
        RAISE EXCEPTION 'Movie hall with id % is not available for the specified time and date', hall_val;
    END IF;

    -- Insert the new movie screening record
    INSERT INTO movie_screening (movieid, date, starttime, endtime, pricestandard, pricepremium, threedimensional, language, hallnumber)
    VALUES (movie_id, date_val, start_time_val, end_time_val, price_standard_val, price_premium_val, is_3d, language_val, hall_val);
END
$$;

alter procedure add_movie_screening(varchar, date, time, numeric, numeric, boolean, varchar, integer) owner to postgres;
```

- Usunięcie wybranego seansu (admin)

```postgresql
create procedure delete_movie_screening(IN movie_title text, IN screening_date date, IN screening_time time without time zone)
    language plpgsql
as
$$
DECLARE
    screening_id INTEGER;
BEGIN
    -- Перевірка наявності показу фільму з заданими параметрами
    SELECT ms.moviescreeningid
    INTO screening_id
    FROM movie_screening ms
    JOIN movies m ON ms.movieid = m.movieid
    WHERE m.title = movie_title
      AND ms.date = screening_date
      AND ms.starttime = screening_time;

    -- Якщо показ не знайдено, викликаємо помилку
    IF NOT FOUND THEN
        RAISE EXCEPTION 'No movie screening for the movie "%", date "%", and time "%" exists', movie_title, screening_date, screening_time;
    END IF;

    -- Видалення знайденого показу
    DELETE FROM movie_screening
    WHERE moviescreeningid = screening_id;
END
$$;

alter procedure delete_movie_screening(text, date, time) owner to postgres;
```

## 6. **Funkcje**

- Wyświetlenie wszystkich seansów dla danego movie, które są grane po wskazywanym terminie

```postgresql
create function get_movie_sessions(p_title character varying, target_date date, target_time time without time zone)
    returns TABLE(moviescreeningid integer, movieid integer, date date, starttime time without time zone, pricestandard numeric, pricepremium numeric, moviehall integer, threedimensional boolean, language character varying)
    language plpgsql
as
$$
BEGIN
    RETURN QUERY
    SELECT
        movie_screening.moviescreeningid,
        movie_screening.movieid,
        movie_screening.date,
        movie_screening.starttime,
        movie_screening.pricestandard,
        movie_screening.pricepremium,
        movie_screening.hallnumber,
        movie_screening.threedimensional,
        movie_screening.language
    FROM
        movie_screening
    INNER JOIN
        movies as m on movie_screening.MovieID = m.movieid
    WHERE
        m.title = get_movie_sessions.p_title
        AND (movie_screening.date > get_movie_sessions.target_date
            OR (movie_screening.date >= get_movie_sessions.target_date AND movie_screening.starttime > get_movie_sessions.target_time));
END;
$$;

alter function get_movie_sessions(varchar, date, time) owner to postgres;
```

- Wyświetlenie wszystkich zajętych miejsc dla danego seansu

```postgresql
CREATE OR REPLACE FUNCTION get_occupied_seats(screening_id integer)
    RETURNS TABLE(seat_number integer)
    LANGUAGE plpgsql
AS
$$
BEGIN
    RETURN QUERY
    SELECT
        seatnumber AS seat_number
    FROM
        occupied_seats
    WHERE
        moviescreeningid = get_occupied_seats.screening_id;
END;
$$;

ALTER FUNCTION get_occupied_seats(integer) OWNER TO postgres;
```

- Wyświetlenie wszystkich filmów aktualnie granych w kinie

```postrgresql
create function get_current_movies(p_date date)
    returns TABLE(movieid integer, moviecategoryid integer, title character varying, startdate date, enddate date, duration integer, description character varying, image bytea, director character varying, minage integer, production character varying, originallanguage character varying, rank double precision)
    language plpgsql
as
$$
BEGIN
    RETURN QUERY
    SELECT
        m.movieid,
        m.moviecategoryid,
        m.title,
        m.startdate,
        m.enddate,
        m.duration,
        m.description,
        m.image,
        m.director,
        m.minage,
        m.production,
        m.originallanguage,
        m.rank
    FROM
        movies m
    WHERE
        m.startdate <= p_date and p_date <= m.enddate;
END;
$$;

alter function get_current_movies(date) owner to postgres;
```

- Wyświetlenie wszystkich filmów, które będą grane w przyszłości

```postgresql
create function get_upcoming_movies(p_date date)
    returns TABLE(movieid integer, moviecategoryid integer, title character varying, startdate date, enddate date, duration integer, description character varying, image bytea, director character varying, minage integer, production character varying, originallanguage character varying, rank double precision)
    language plpgsql
as
$$
BEGIN
    RETURN QUERY
    SELECT
        m.movieid,
        m.moviecategoryid,
        m.title,
        m.startdate,
        m.enddate,
        m.duration,
        m.description,
        m.image,
        m.director,
        m.minage,
        m.production,
        m.originallanguage,
        m.rank
    FROM
        movies m
    WHERE
        p_date < m.startdate;
END;
$$;

alter function get_upcoming_movies(date) owner to postgres;
```

- Sprawdzenie, czy sala jest dostępna w określonym terminie

```postgresql
create function is_moviehall_available(hall_val integer, date_val date, start_time_val time without time zone, end_time_val time without time zone) returns boolean
    language plpgsql
as
$$
DECLARE
    is_available boolean;
BEGIN
    SELECT NOT EXISTS (
        SELECT 1 FROM movie_screening
        WHERE hallnumber = hall_val
        AND date = date_val
        AND (starttime <= end_time_val AND endtime >= start_time_val)
    ) INTO is_available;

    RETURN is_available;
END;
$$;

alter function is_moviehall_available(integer, date, time, time) owner to postgres;
```

- Obliczanie end_time dla seansu (jest potrzebne do wstawienia danych w move_screenings)

```postgresql
create function calculate_end_time(start_time_param time without time zone, duration_param integer) returns time without time zone
    language plpgsql
as
$$
DECLARE
    end_time_result TIME;
BEGIN
    SELECT (start_time_param + INTERVAL '1 minute' * duration_param) INTO end_time_result;
    RETURN end_time_result;
END;
$$;

alter function calculate_end_time(time, integer) owner to postgres;
```

- Wyświetlenie terminów wszystkich seansów prowadzonych w danej sali

```postgresql
create function get_screenings_by_hall(hall_number_param integer, date_param date)
    returns TABLE(movieid integer, title character varying, starttime time without time zone, endtime time without time zone)
    language plpgsql
as
$$
BEGIN
    RETURN QUERY
    SELECT DISTINCT
        ms.movieid,
        m.title,
        ms.starttime,
        ms.endtime
    FROM
        movie_screening ms
    INNER JOIN movies m
        on ms.movieid = m.movieid
    WHERE
        ms.hallnumber = hall_number_param
        AND ms.date = date_param
    ORDER BY
        ms.starttime;
END;
$$;

alter function get_screenings_by_hall(integer, date) owner to postgres;
```

- Wyświetlenie wszystkich biletów dla danego użytkownika

```postgresql
create function get_tickets_for_user(user_id integer)
    returns TABLE(ticket_id integer, status character, date date, title character varying, start_time time without time zone, duration integer, hall_number integer, sit_number integer, price numeric, ordered_on_date date, ordered_on_time time without time zone)
    language plpgsql
as
$$
begin
    return query
    select
        t.ticketid,
        t.status,
        ms.Date,
        m.title,
        ms.StartTime,
        m.duration,
        ms.hallnumber,
        t.seatnumber,
        CASE
            WHEN is_premium_place(t.seatnumber) THEN ms.PricePremium
            ELSE ms.PriceStandard
        END AS price,
        t.orderedondate,
        t.orderedontime
    from
        tickets t
    inner join
        movie_screening as ms on t.MovieScreeningID = ms.MovieScreeningID
    inner join
        movies as m on m.movieid = ms.movieid
    where
        t.customerid = user_id
    order by date, starttime;
end;
$$;

alter function get_tickets_for_user(integer) owner to postgres;
```

- Sprawdzenie, czy dane miejsce jest mejscem z kategorii Premium (wszystkie sale mają tyle samo miejsc, ostatni rząd symbolizuje premium mejsca)

```postgresql
create function is_premium_place(place_value integer) returns boolean
    language plpgsql
as
$$
BEGIN
    IF place_value >= 1 AND place_value <= 11 THEN
        RETURN TRUE;
    ELSE
        RETURN FALSE;
    END IF;
END;
$$;

alter function is_premium_place(integer) owner to postgres;
```

- Wyświetlenie danych o filmie wraz z nazwą kategorii

```postgresql
create function get_movie_by_title(p_title character varying)
    returns TABLE(movieid integer, categoryname character varying, title character varying, startdate date, enddate date, duration integer, description character varying, image bytea, director character varying, minage integer, production character varying, originallanguage character varying, rank double precision)
    language plpgsql
as
$$
BEGIN
    RETURN QUERY
    SELECT
        m.movieid,
        mc.categoryname,
        m.title,
        m.startdate,
        m.enddate,
        m.duration,
        m.description,
        m.image,
        m.director,
        m.minage,
        m.production,
        m.originallanguage,
        m.rank
    FROM
        movies m
    INNER JOIN
        movie_categories as mc
    on m.moviecategoryid = mc.moviecategoryid
    WHERE p_title = m.title;
END;
$$;

alter function get_movie_by_title(varchar) owner to postgres;
```

- Wyświetlenie wszystkich dostępnych w danym dniu seansów wraz z nazwą filmu

```postgresql
create function get_movie_screenings_on_date(target_date date)
    returns TABLE(movie_title character varying, start_time time without time zone, hall_number integer, available_seats integer)
    language plpgsql
as
$$
BEGIN
    RETURN QUERY
    SELECT m.title, ms.starttime, ms.hallnumber, ((SELECT COUNT(*) FROM hall_seats WHERE moviehallnumber = ms.hallnumber) - COALESCE((SELECT COUNT(*) FROM tickets WHERE moviescreeningid = ms.moviescreeningid), 0))::integer AS available_seats
    FROM movies m
    INNER JOIN movie_screening ms ON m.movieid = ms.movieid
    WHERE ms.date = target_date;
END;
$$;

alter function get_movie_screenings_on_date(date) owner to postgres;
```

## 7. **Triggery**

- Zabronienie rezerwacji na seans który jest grany za mniej niż 2 godziny (możliwy jest wyłącznie ZAKUP biletu na taki seans)

```postgresql
create function check_reservation_period() returns trigger
    language plpgsql
as
$$
DECLARE
    screening_date DATE;
    screening_start_time TIME;
BEGIN
    SELECT date, starttime
    INTO screening_date, screening_start_time
    FROM movie_screening
    WHERE MovieScreeningID = NEW.MovieScreeningID;

    IF NEW.Status = 'New' and (screening_date + screening_start_time) <= (NEW.OrderedOnDate + NEW.OrderedOnTime + interval '2 hours') THEN
        RAISE EXCEPTION 'The movie screening must be later than 2 hours from the reservation time';
    END IF;

    RETURN NEW;
END;
$$;

alter function check_reservation_period() owner to postgres;
```

```postgresql
CREATE TRIGGER validate_reservation_time
    BEFORE INSERT
    ON tickets
    FOR EACH ROW
EXECUTE FUNCTION check_reservation_period();
```

## 8. **Indeksy**

```postgresql
-- Tabela Appuser
CREATE INDEX idx_appuser_email ON user_api_appuser(email);
CREATE INDEX idx_appuser_username ON user_api_appuser(username);

-- Tabela HallSeats
CREATE INDEX idx_hallseats_moviehallnumber ON hall_seats(moviehallnumber);

-- Tabela MovieScreening
CREATE INDEX idx_moviescreening_movieid ON movie_screening(movieid);
CREATE INDEX idx_moviescreening_date ON movie_screening(date);
CREATE INDEX idx_moviescreening_starttime ON movie_screening(starttime);

-- Tabela Movies
CREATE INDEX idx_movies_moviecategoryid ON movies(moviecategoryid);
CREATE INDEX idx_movies_title ON movies(title);
CREATE INDEX idx_movies_startdate ON movies(startdate);
CREATE INDEX idx_movies_enddate ON movies(enddate);

-- Tabela Tickets
CREATE INDEX idx_tickets_customerid ON tickets(customerid);
CREATE INDEX idx_tickets_moviescreeningid ON tickets(moviescreeningid);
CREATE INDEX idx_tickets_seatnumber ON tickets(seatnumber);
```

## 9. **Widoki strony internetowej**

### Strona główna (home)

Na stronie są pokazane grane teraz i w przyszłości filmy, działa wyszukiwanie filmu

![](img/11.png)

<div style="page-break-after: always;"></div>

### Movies

Na stronie są wyświetlane wszystkie movies dostępne teraz, oraz movies, które będą dostępne w przyszłości. Sortowanie domyślnie ustawione od daty premiery filmu. Na stronie działa wyszukiwanie po nazwie filmu, filtrowanie po kategorii, sortowanie według zadanych parametrów

![](img/12.png)

<div style="page-break-after: always;"></div>

### Movie

Strona wybranego filmu, gdzie są wyświetlane informację dotyczące danego filmu wraz z kategorią. Jest możliwość przeglądania dostępnych w ciągu przyszłych 7 dni terminów seansów i przejście do strony danego seansu (opisana niżej)

![](img/13.png)

<div style="page-break-after: always;"></div>

### Showtime

Strona wybranego seansu filmu, gdzie są wyświetlane informację dotyczące danego seansu. Klient ma możliwość podglądu zajętych miejsc na dany senas (są zaznaczone na szaro), oraz wyboru miejsca wśród Standard (12-84) albo Premium (1-11) miejsc, które też są zaznaczone różnymi kolorami i mają różne ceny

Początkowy wygląd strony:

![](img/14.png)

Wygląd strony po kliknięciu na miejsce:

![](img/15.png)

<div style="page-break-after: always;"></div>

### UserProfile

Strona profilu użytkownika, gdzie są 2 przełączniki pomiędzy ticketami i ustawieniami. W zakładce "My tickets" są wyświetlane wszystkie tickety klienta wraz z informacją o seansie. W contenerze biletów, mających status "New", jest możliwość zakupu danego biletu lub jego anulowania. W zakładce "Settings" istnieje możliwość zmiany hasła użytkownika (na razie nie zrealizowana technicznie)

![](img/16.png)

![](img/17.png)

<div style="page-break-after: always;"></div>

### Login & Register

Na razie logowanie i rejestracja działają na poziomie bazy danych (pojawiają się odpowiednie dane w tabelu userów), natomiast w tym momencie nie działa ustawienie sesji użytkownika

![](img/18.png)

![](img/19.png)

<div style="page-break-after: always;"></div>

### Admin

Strona posiada 3 przełączniki: "View Data" - podgląd danych z tabel, "Data manager" - zarządzanie danymi tabel (dodawanie rekordów, ich modyfikacja oraz usunięcie), "Data analysis" - podgląd statystycznych danych bez możliwości modyfikacji (wywołania widoku lub funkcji, niektóre mają parametry, a niektóre nie).

- View Data

![](img/20.png)

Categories:

![](img/21.png)

Movies:

![](img/22.png)

![](img/23.png)

MovieScreenings:

![](img/24.png)

![](img/25.png)

- Data manager

![](img/26.png)

Przykładowo - Add Week-Templated Movie Screenings:

![](img/27.png)

- Data analysis

![](img/28.png)

Show Movie Screenings by Hall:

![](img/29.png)

Show revenue for Movie on OrderDate:

![](img/30.png)

Show average prices per category over past/upcoming 6 months:

![](img/31.png)

Show today Movie Screenings:

![](img/32.png)

## 10. **Testowanie poprawności działania procedur na stronie**

(Test został wykonany na wcześniejszej wersji frontendu jednak działanie bazy danych nie zmieniło się)

### Użytkownik

Najpierw przetestujemy rezerwację i zakup biletu, zróbmy to dla przykładu na jednym seansie, przy czym weźmiemy różne miejsca, żeby sprawdzić, czy cena będzie się różniła.

- Rezerwacja biletu

Tabela tickets przed wywołaniem procedury:

![](img/51.png)

Na potrzeby działania aplikacji oraz jej przejrzystosci, stworzylismy funkcję handle_request aby decydowała o wywołaniu konkretnej funkcji w zależnosci od action.

Funkcja handle_request:

```python
    @csrf_exempt
def handle_request(request):
    if request.method == 'POST':
        try:
            data = json.loads(request.body)
            action = data.get('action')
            if action == 'add_seat':
                return add_movie_screening_seat(data)
            elif action == 'reserve_seat':
                return reserve_movie_screening_seat(data)
            elif action == 'buy_seat':
                return buy_movie_screening_seat(data)
            else:
                return JsonResponse({'error': 'Unknown action'}, status=400)
        except json.JSONDecodeError:
            return JsonResponse({'error': 'Invalid JSON'}, status=400)
        except Exception as e:
            return JsonResponse({'error': str(e)}, status=500)
    else:
        return JsonResponse({'error': 'Invalid HTTP method'}, status=405)
```

Za pomocą polecenia connection.cursor() łączymy się z naszą bazą danych a następnie wywołujemy procedurę reserve_movie_screening_seat z odpowiednimi parametrami.

Funkcja rezerwująca miejsce w django:

```python
def reserve_movie_screening_seat(data):
    try:
        seat_number = data['seat_number']
        movie_screening_id = data['movie_screening_id']
        available = data['available']
        with connection.cursor() as cursor:
            cursor.execute("CALL reserve_movie_screening_seat(%s, %s, %s, %s, %s);",
                           [specific_customer, seat_number, movie_screening_id, specific_date, specific_time])
        return JsonResponse({'message': 'Seat reserved successfully'}, status=201)
    except KeyError as e:
        return JsonResponse({'error': f'Missing key: {str(e)}'}, status=400)
    except Exception as e:
        return JsonResponse({'error': str(e)}, status=500)
```

Wybrane przez nas miejsce F4, którego cena jest Standard:

![](img/52.png)

![](img/53.png)

Jak widzimy, nie da się zarezerwować tego miejsca, ponieważ seans zaczyna się 22.05.2024 o 14:30, a ustawiony systemowy czas to 22.05.2024, 13:00 (patrz punkt 2.10).
Spróbujemy więc wybrać inny seans, to samo miejsce:

![](img/54.png)

Widzimy, że miejsce już jest zajęte:

![](img/55.png)

Tabela tickets po wywołaniu procedury:

![](img/56.png)

- Zakup biletu

W django logika zakupu biletu wygląda identycznie jak przy rezerwacji, zmieniamy jedynie wywołaną procedurę z bazy.

Tabela tickets przed wywołaniem procedury:

![](img/51.png)

Wybrane przez nas miejsce A2, którego cena jest Premium:

![](img/57.png)

Widzimy, że miejsce już jest zajęte:

![](img/58.png)

Tabela tickets po wywołaniu procedury:

![](img/59.png)

A teraz sprawdźmy poprawność wyliczania ceny dla tych biletów (Standard/Premium). W tym celu popatrzymy na informację wyświetlane w profilu użytkownika:

![](img/60.png)

Jak widać, cena biletu została policzona poprawnie.

- Zmiana statusu biletu

Spróbujmy kupić bilet, który jest zarezerwowany. W tym celu klikniemy odpowiedni przycisk w profilu użytkownika.
Dostaliśmy wiadomość, że zmiana się powiodła:

![](img/61.png)

Już teraz ten zarezerwowany ticket jest opłacony:

![](img/62.png)

### Admin

- Dodanie nowej kategorii

Tabela movie_categories przed wywołaniem procedury:

![](img/33.png)

Wywołanie procedury z panelu admina na stronie:

![](img/34.png)

Tabela movie_categories po wywołaniu procedury:

![](img/35.png)

- Usunięcie kategorii

Wywołanie procedury z panelu admina na stronie:

![](img/36.png)

Tabela movie_categories po wywołaniu procedury:

![](img/33.png)

- Dodanie nowego filmu

Tabela movies przed wywołaniem procedury:

![](img/37.png)

Wywołanie procedury z panelu admina na stronie:

![](img/38.png)

Tabela movies po wywołaniu procedury:

![](img/39.png)

Powstała nowa strona:

![](img/40.png)

- Aktualizacja danych wybranego filmu

Wywołanie procedury z panelu admina na stronie:

![](img/41.png)

Tabela movies po wywołaniu procedury:

![](img/42.png)

- Usunięcie filmu

Wywołanie procedury z panelu admina na stronie:

![](img/43.png)

Tabela movies po wywołaniu procedury:

![](img/44.png)

- Dodanie seansów na określoną liczbę dni

Tabela movie_screening przed wywołaniem procedury:

![](img/45.png)

Spróbujemy dodać seansy na 7 dni, zaczynając od 11-06-2024, mimo że ostatni dzień kiedy film jest grany to 15-06-2024.
Wywołanie procedury z panelu admina na stronie:

![](img/46.png)

Jak widać, dostaliśmy błąd. Sprawdźmy, czy zostałe utrwalone seansy dla terminów, które są poprawne.
Tabela movie_screening po wywołaniu procedury:

![](img/45.png)

Jak widać, błąd przerwał całą transakcję i poprawne dane nie zostały dodane. Spróbujmy zmienić liczbę dni na zgodne z zasadami:

![](img/47.png)

Po wpisywaniu liczby dni równej 4, dostaliśmy komunikat, że udało się dodać te dane. 
Tabela movie_screening po wywołaniu procedury:

![](img/48.png)

- Usunięcie wybranego seansu

Wywołanie procedury z panelu admina na stronie:

![](img/49.png)

Tabela movie_screening po wywołaniu procedury:

![](img/50.png)

## 11. **Pozostałe ciekawe funkcje stworzone w django które warto przedstawić**

Pobranie wszystkich miejsc dla konkretnej sali dla konkretnego seansu filmowe wraz z ich dostępnoscią:

```python
def get_movie_screenings_by_hall(request):
    if request.method == 'GET':
        movie_hall = request.GET.get('number')
        hall_date = request.GET.get('date')

        try:
            with connection.cursor() as cursor:
                cursor.execute(
                    "SELECT * FROM get_screenings_by_hall(%s, %s)",
                    [movie_hall, hall_date]
                )
                columns = [col[0] for col in cursor.description]
                results = cursor.fetchall()  # Fetch all rows

            if results:
                result_dicts = [dict(zip(columns, row)) for row in results]
                return JsonResponse(result_dicts, safe=False)
            else:
                return JsonResponse({'error': 'No results found for the given movie hall and date.'}, status=404)
        except Exception as e:
            return JsonResponse({'error': str(e)}, status=500)
```

Pobieranie movie_details z bazy danych na podstawie zmiennej tittle przekazywanej zawsze jako ostatni fragment urla. Przed odpowiedzią serwera zamieniamy pobrane z bazy dane na format JSON:

```python
@require_GET
def get_movie_details(request, title):
    if not title:
        return JsonResponse({'error': 'Title parameter is required'}, status=400)

    try:
        with connection.cursor() as cursor:
            cursor.execute("SELECT * FROM get_movie_by_title(%s)", [title])
            row = cursor.fetchone()
            if row:
                columns = [col[0] for col in cursor.description]
                movie = dict(zip(columns, row))
                if 'image' in movie and movie['image'] is not None:
                    movie['image'] = base64.b64encode(movie['image']).decode('utf-8')

                return JsonResponse(movie, safe=False)
            else:
                return JsonResponse({'error': 'Movie not found'}, status=404)
    except Exception as e:
        return JsonResponse({'error': str(e)}, status=500)
```

Pobranie wszystkich seansów filmowych do 7 dni do przodu dla konkretnego filmu:

```python
def get_movie_sessions(request, title):
    if not title:
        return JsonResponse({'error': 'Title parameter is required'}, status=400)
    try:
        with connection.cursor() as cursor:
            cursor.execute(
                "SELECT * FROM get_movie_sessions(%s, %s, %s) order by date, starttime",
                [title, specific_date, specific_time]
            )
            rows = cursor.fetchall()

        columns = [col[0] for col in cursor.description]
        data = [dict(zip(columns, row)) for row in rows]
        return JsonResponse(data, safe=False)
    except Exception as e:
        return JsonResponse({'error': str(e)}, status=500)
```